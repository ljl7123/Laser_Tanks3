<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Play background music (actually a loop of a short sound).
//audio_sound_gain(sound_cool_background_noise, .01, 0);
//audio_play_sound(sound_cool_background_noise, 0 , true);


//Create the player
instance_create(random(room_width), random(room_height), object_player);

//init tile timer 
tile_timer_init();

//mode stuff 
//score attack
timer_val_def = 60;
timer_val = timer_val_def;
time_attack_score = 0;

//for writing to file
hs = working_directory + "hiscores.txt";
can_do_file = true;

//create the arena info
arena_info = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//at the end of the game room event, destroy the list to avoid memory leaks
ds_list_destroy(score_list);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//in case we need to return to this room
global.lastroom = room;

//Restart the game if the player presses select
if (gamepad_button_check(0, gp_select) || keyboard_check(ord("R"))){
    game_restart();
}

//if there is not player, create a player if you click 
//and there is still time left (this assumes playing time attack)
if (!instance_exists(object_player) &amp;&amp; timer_val &gt;0){
        window_set_cursor(cr_cross);
        if(mouse_check_button_released(mb_left)){
                instance_create( mouse_x, mouse_y, object_player);
            }
}

//Go to the puase menu if the player
//presses start or escape
if (gamepad_button_check(0, gp_start) || keyboard_check(vk_escape)){
    room_persistent = true;
    room_goto_next();
}

//generate tiles
generate_tiles();

//if the timer value is less than zero and we are playing 
//time attack then destroy the player
if (global.mode_counter ==0 &amp;&amp; timer_val &lt;0){
    if (instance_exists(object_player)){
        object_player.hp = 10;
    }
}

//decrease timer
timer_val -= per_second;

//change the pitch and speed (frequency?) of the music
//based off of how much damage the player has taken
if (instance_exists(object_player)){
    audio_sound_pitch(sound_terrence_music, (timer_val_def - timer_val) / (timer_val_def));
} else{
    audio_stop_sound(sound_terrence_music);
}

//trim the arena info
if (ds_list_size(arena_info) &gt; 5){
    ds_list_delete(arena_info, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//debug info text housekeeping
draw_set_font(font_debug_font);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_color(c_white);

//if the global.debug variable is true, then display the debug information
if (global.debug){
    draw_text(view_xview[0], view_yview[0] + 100, "Total Instances: " + string(instance_count));
    draw_text(view_xview[0], view_yview[0] + 150, "Total Tiles: " + string(instance_number(object_tile)));
    draw_text(view_xview[0], view_yview[0] + 200, "Total Tanks: " + string(instance_number(object_tank_parent)));
    draw_text(view_xview[0], view_yview[0] + 250, "Total Blocks: " + string(instance_number(object_block_parent)));
    draw_text(view_xview[0], view_yview[0] + 300, "Total Fragments: " + string(instance_number(object_parent_fragment)));
    draw_text(view_xview[0], view_yview[0] + 350, "Total Bullets: " + string(instance_number(object_bullet)));
    
    //only do this stuff if there is a player alive
    if (instance_exists(object_player)){
        draw_text(view_xview[0], view_yview[0] + 400, "Player: " + "x: " + string(object_player.x) + " y: " + string(object_player.y) );
        draw_text(view_xview[0], view_yview[0] + 450, "Player: " + "h_speed: " + string(object_player.tank_hspeed) + " v_speed: " + string(object_player.tank_vspeed) );
        draw_text(view_xview[0], view_yview[0] + 500, "Player: " + "h_acceleration: " + string(object_player.h_acceleration) + " v_acceleration: " + string(object_player.v_acceleration));
        draw_text(view_xview[0], view_yview[0] + 550, "Player: " + "direction: " + string(object_player.direction) + " image_angle: " + string(object_player.image_angle));
        
        if (instance_exists(object_player.my_turret)){
            draw_text(view_xview[0], view_yview[0] + 600, "Player: " + "turret angle: " + string(object_player.my_turret.image_angle));
        }
        
        draw_text(view_xview[0], view_yview[0] + 650, "Player: " + "kickback_angle: " + string(object_player.opp_angle));
        
        //only do if the bullet exists
        if (instance_exists(object_player.my_bullet)){
            draw_text(view_xview[0], view_yview[0] + 700, "Player: " + " bullet angle: " + string(object_player.my_bullet.image_angle));
        }
    }
    draw_text(view_xview[0], view_yview[0] + 750, "Debug Mode: " + string(global.debug));
}

//draw the timer and the score
if (global.mode_counter == 0 &amp;&amp; timer_val &gt; 0){
    crt_cust_txt(font_pixel, 1, c_red);
    draw_text_transformed(view_xview + view_wview[0]/2 -500, view_yview[0] + 250, string(round(timer_val)),4,4,0);
        if (instance_exists(object_player)){
             draw_set_color(object_player.image_blend); //set the score equal to the color of the player
        }
    
    draw_text_transformed(view_xview + view_wview[0]/2 + 500, view_yview[0] + 250, string(time_attack_score),4,4,0);
    //Line seperating the score and timer    
    draw_set_colour(c_white);
    draw_text_transformed(view_xview + view_wview[0]/2, view_yview[0] + 250, string("|"),4,4,0);  
} else {
    //if the timer value is less then zero then draw the 
    //score information
    crt_cust_txt(font_pixel, 1, global.colors[global.color_counter]);
    draw_text_transformed(view_xview + view_wview[0]/2, view_yview[0] + 150, "GAME OVER",2,2,0);
    draw_text_transformed(view_xview + view_wview[0]/2 , view_yview[0] + 425, "HIGHSCORES:",.75,.75,0);
    
    //do the file writing
    if (can_do_file){
        can_do_file = false;
        file = file_text_open_append(hs);
        file_text_write_string(file, global.player_name + " " + string(time_attack_score));
        file_text_writeln(file);
        file_text_close(file); 
        
        //do the file reading
        file = file_text_open_read(hs);
        //store all of the file data in a dl_list
        score_list = ds_list_create();
        //add score lines to the ds_list until reach the end of file or a blank line
        while(file_text_eof(file) == false){
            ds_list_add(score_list, file_text_read_string(file)); //get the string
            file_text_readln(file); //go to the next line until we can't
        }
        //I probably used too many variables, here.        
        //sort the list which is filled with hiscore strings (stupid bubble sort)
        for (i = 0; i &lt; ds_list_size(score_list) - 1; i++ ){
            //we repatedly traverse the unsorted part of the array
            for (j = 0; j &lt; ds_list_size(score_list) - 1; j++){
                score_string1 = ds_list_find_value(score_list, j);
                score_val1 = real(string_digits(score_string1)); //parse the string from the list
                score_string1 = string_letters(score_string1); //trim the number from the string
                
                score_string2 = ds_list_find_value(score_list, j+1);
                score_val2 = real(string_digits(score_string2)) //parse comparison
                score_string2 = string_letters(score_string2); //trim
                 
                //ony swap if the first value is less than the second                                                               
                if (score_val1 &gt; score_val2){
                    
                    temp = score_val1;
                    temp_string = score_string1
                    score_val1 = score_val2;
                    score_string1 = score_string2;
                    score_string1 += " " + string(score_val1);
                    ds_list_replace(score_list, j , score_string1);
                    
                    score_val2 = temp;
                    score_string2 = temp_string;
                    score_string2 += " " + string(score_val2);
                    ds_list_replace(score_list, j + 1 , score_string2);
                } 
            } //end j iteration of bubble sort
        }//end i iteration of bubble sort
       
    } //end file stuff 
    
    //draw the score stuff from the list (backwards because list is in ascending)
    crt_cust_txt(font_pixel, 0, global.colors[global.color_counter]);
    for (i = ds_list_size(score_list) -1; i&gt;=0 ; i--){
        draw_text_transformed(view_xview[0] + view_wview[0]/2 -200 , view_yview[0] + 525 + (ds_list_size(score_list) -1 - i) * 75, string(ds_list_size(score_list) -1 - i) + ". " +  ds_list_find_value(score_list, i) ,.5,.5,0);
        if (ds_list_size(score_list) -1 - i &gt; 14){
            break;
        }
    }
   
} //end else draw the score stuff

//also draw the information for the arena
crt_cust_txt(font_pixel, 0, global.colors[global.color_counter]);
for (i =ds_list_size(arena_info) -1; i &gt;=0 ; i--){
    draw_text_transformed(view_xview[0] + 100, view_yview[0] + view_hview[0]-100 - ((ds_list_size(arena_info) -1 - i) * 75), ds_list_find_value(arena_info,i), 1,1,0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
