<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//global modes array, so that we can figure out what mode 
//the game is in and do some type of behavior
global.modes[0] = "Mode 1";
global.modes[1] = "Mode 2";
global.modes[2] = "Mode 3";

//used for iterating through the modes
global.mode_counter = 0;

//color array
global.colors[0] = c_red;
global.colors[1] = c_yellow;
global.colors[2] = c_blue;
global.colors[3] = c_green;
global.colors[4] = c_purple;
global.colors[5] = c_orange;
global.colors[6] = c_aqua;

//used for iterating through the global.colors
global.color_counter = 0;

//used for storing the player's name
global.player_name = ""; 

//used to make the cursor appear to blink
cursor = "|";
cursor_timer_default = 30 * per_second;
cursor_timer = cursor_timer_default;

//used for letting the playing write
//based on whether or not they have clicked the box
writable = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//store the player's name in the global message variable
if (string_length(keyboard_string) &lt; 14 &amp;&amp; writable){
        global.player_name = keyboard_string;
    } else {
        keyboard_string = global.player_name;
    }
    
//if the timer is zero then make the cursor, blank the cursor string 
if (cursor_timer &lt; 0){
    cursor_timer = cursor_timer_default;
    cursor = " ";    
} else if (cursor_timer &gt;=0 &amp;&amp; writable) {
    cursor = "|";
}

cursor_timer -=per_second;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//set the background color to black
background_colour = c_black;

//if the player clicks start, then go to the player arena
if (menu_element(true, "START", room_width/2, 100, font_pixel, .5, true, c_white )){
    room_goto_next();
} 

//draw name text
menu_element(true, "NAME:", room_width/2 - 250, 250, font_pixel, .5, true, c_white);

//drawing the input box and the input from the keyboard
if (writable){
    draw_rectangle_colour(room_width/2 - 110,215,room_width/2 + 260, 285, global.colors[global.color_counter],global.colors[global.color_counter],global.colors[global.color_counter],global.colors[global.color_counter], false);
}
    
draw_rectangle_colour(room_width/2 - 100,225,room_width/2 + 250, 275, c_white,c_white,c_white,c_white, false);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_text_ext_transformed_colour(room_width/2 - 90, 225, global.player_name + cursor, 100, 2000, .35, .35, 0,  global.colors[global.color_counter],  global.colors[global.color_counter], global.colors[global.color_counter], global.colors[global.color_counter],1 );


//hovering behavior
if(point_in_rectangle(mouse_x,mouse_y, room_width/2 - 100,225,room_width/2 + 250, 275)){
    window_set_cursor(cr_beam);
} else {
    window_set_cursor(cr_default);
}

//clicking behavior
if (mouse_check_button_released(mb_left)){
        if(point_in_rectangle(mouse_x,mouse_y, room_width/2 - 100,225,room_width/2 + 250, 275)){
            writable = true;
    } else {
            writable = false;
    }

} //end left click

//color picker
if (global.color_counter &lt; array_length_1d(global.colors)){
    switch(global.colors[global.color_counter]){
        case c_red: color_text = "red" break;
        case c_yellow: color_text = "yellow" break;
        case c_blue: color_text = "blue" break;
        case c_green: color_text = "green" break;
        case c_purple: color_text = "purple" break;
        case c_orange: color_text = "orange" break;
        case c_aqua: color_text = "aqua" break;
    }
    menu_element(true, color_text , room_width/2, 400, font_pixel, .5, true, global.colors[global.color_counter]);
}

//color picker arrows
//draw the right color arrow and do behavior
if (draw_and_wrap_arrow(room_width/2 + 250, room_width/2 + 400, 400)){ 
    global.color_counter++;
    //wrap back around to beginning of global.modes array
    if (global.color_counter &gt;= array_length_1d(global.colors)){
        global.color_counter = 0;
    }
}

//draw the left color arrow and do behavior
 if (draw_and_wrap_arrow(room_width/2 - 250, room_width/2 - 400, 400)){
    global.color_counter--;  
    //wrap back around to end of global.modes array
     if (global.color_counter &lt; 0){
        global.color_counter = array_length_1d(global.colors)-1;
    }
}

//text to be drawn depending on what mode type we need to display
if (global.mode_counter &lt; array_length_1d(global.modes)){
    menu_element(true, global.modes[global.mode_counter], room_width/2, 500, font_pixel, .5, true, c_white);
}

//draw the right mode arrow and do behavior
if (draw_and_wrap_arrow(room_width/2 + 250, room_width/2 + 400, 500)){ 
    global.mode_counter++;
    //wrap back around to beginning of global.modes array
    if (global.mode_counter &gt;= array_length_1d(global.modes)){
        global.mode_counter = 0;
    }
}

//draw the left mode arrow and do behavior
 if (draw_and_wrap_arrow(room_width/2 - 250, room_width/2 - 400, 500)){
    global.mode_counter--;  
    //wrap back around to end of global.modes array
     if (global.mode_counter &lt; 0){
        global.mode_counter = array_length_1d(global.modes)-1;
    }
}

//draw the back text (to the main menu) and do behavior
 if (menu_element(true, "BACK", room_width/2, 700, font_pixel, .5, true, c_white)){
    room_goto_previous();
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
